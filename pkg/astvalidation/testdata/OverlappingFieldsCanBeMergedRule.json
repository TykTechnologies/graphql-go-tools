{
  "tests": [
    {
      "name": "UniqueFields",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment uniqueFields on Dog {\n        name\n        nickname\n      }\n    ",
      "errors": []
    },
    {
      "name": "IdenticalFields",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment mergeIdenticalFields on Dog {\n        name\n        name\n      }\n    ",
      "errors": []
    },
    {
      "name": "IdenticalFieldsWithIdenticalArgs",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {\n        doesKnowCommand(dogCommand: SIT)\n        doesKnowCommand(dogCommand: SIT)\n      }\n    ",
      "errors": []
    },
    {
      "name": "IdenticalFieldsWithIdenticalDirectives",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment mergeSameFieldsWithSameDirectives on Dog {\n        name @include(if: true)\n        name @include(if: true)\n      }\n    ",
      "errors": []
    },
    {
      "name": "DifferentArgsWithDifferentAliases",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment differentArgsWithDifferentAliases on Dog {\n        knowsSit: doesKnowCommand(dogCommand: SIT)\n        knowsDown: doesKnowCommand(dogCommand: DOWN)\n      }\n    ",
      "errors": []
    },
    {
      "name": "DifferentDirectivesWithDifferentAliases",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment differentDirectivesWithDifferentAliases on Dog {\n        nameIfTrue: name @include(if: true)\n        nameIfFalse: name @include(if: false)\n      }\n    ",
      "errors": []
    },
    {
      "name": "DifferentSkip/includeDirectivesAccepted",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment differentDirectivesWithDifferentAliases on Dog {\n        name @include(if: true)\n        name @include(if: false)\n      }\n    ",
      "errors": []
    },
    {
      "name": "SameAliasesWithDifferentFieldTargets",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment sameAliasesWithDifferentFieldTargets on Dog {\n        fido: name\n        fido: nickname\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"fido\" conflict because \"name\" and \"nickname\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "SameAliasesAllowedOnNon-overlappingFields",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment sameAliasesWithDifferentFieldTargets on Pet {\n        ... on Dog {\n          name\n        }\n        ... on Cat {\n          name: nickname\n        }\n      }\n    ",
      "errors": []
    },
    {
      "name": "AliasMaskingDirectFieldAccess",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment aliasMaskingDirectFieldAccess on Dog {\n        name: nickname\n        name\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"name\" conflict because \"nickname\" and \"name\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "DifferentArgsSecondAddsAnArgument",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment conflictingArgs on Dog {\n        doesKnowCommand\n        doesKnowCommand(dogCommand: HEEL)\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"doesKnowCommand\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "DifferentArgsSecondMissingAnArgument",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment conflictingArgs on Dog {\n        doesKnowCommand(dogCommand: SIT)\n        doesKnowCommand\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"doesKnowCommand\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "ConflictingArgValues",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment conflictingArgs on Dog {\n        doesKnowCommand(dogCommand: SIT)\n        doesKnowCommand(dogCommand: HEEL)\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"doesKnowCommand\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "ConflictingArgNames",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment conflictingArgs on Dog {\n        isAtLocation(x: 0)\n        isAtLocation(y: 0)\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"isAtLocation\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "AllowsDifferentArgsWhereNoConflictIsPossible",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment conflictingArgs on Pet {\n        ... on Dog {\n          name(surname: true)\n        }\n        ... on Cat {\n          name\n        }\n      }\n    ",
      "errors": []
    },
    {
      "name": "EncountersConflictInFragments",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        ...A\n        ...B\n      }\n      fragment A on Type {\n        x: a\n      }\n      fragment B on Type {\n        x: b\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 7,
              "column": 9
            },
            {
              "line": 10,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "ReportsEachConflictOnce",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        f1 {\n          ...A\n          ...B\n        }\n        f2 {\n          ...B\n          ...A\n        }\n        f3 {\n          ...A\n          ...B\n          x: c\n        }\n      }\n      fragment A on Type {\n        x: a\n      }\n      fragment B on Type {\n        x: b\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 18,
              "column": 9
            },
            {
              "line": 21,
              "column": 9
            }
          ]
        },
        {
          "message": "Fields \"x\" conflict because \"c\" and \"a\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 14,
              "column": 11
            },
            {
              "line": 18,
              "column": 9
            }
          ]
        },
        {
          "message": "Fields \"x\" conflict because \"c\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 14,
              "column": 11
            },
            {
              "line": 21,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "DeepConflict",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          x: a\n        },\n        field {\n          x: b\n        }\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"field\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 11
            },
            {
              "line": 6,
              "column": 9
            },
            {
              "line": 7,
              "column": 11
            }
          ]
        }
      ]
    },
    {
      "name": "DeepConflictWithMultipleIssues",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          x: a\n          y: c\n        },\n        field {\n          x: b\n          y: d\n        }\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"field\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields and subfields \"y\" conflict because \"c\" and \"d\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 11
            },
            {
              "line": 5,
              "column": 11
            },
            {
              "line": 7,
              "column": 9
            },
            {
              "line": 8,
              "column": 11
            },
            {
              "line": 9,
              "column": 11
            }
          ]
        }
      ]
    },
    {
      "name": "VeryDeepConflict",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          deepField {\n            x: a\n          }\n        },\n        field {\n          deepField {\n            x: b\n          }\n        }\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"field\" conflict because subfields \"deepField\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 4,
              "column": 11
            },
            {
              "line": 5,
              "column": 13
            },
            {
              "line": 8,
              "column": 9
            },
            {
              "line": 9,
              "column": 11
            },
            {
              "line": 10,
              "column": 13
            }
          ]
        }
      ]
    },
    {
      "name": "ReportsDeepConflictToNearestCommonAncestor",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          deepField {\n            x: a\n          }\n          deepField {\n            x: b\n          }\n        },\n        field {\n          deepField {\n            y\n          }\n        }\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"deepField\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 4,
              "column": 11
            },
            {
              "line": 5,
              "column": 13
            },
            {
              "line": 7,
              "column": 11
            },
            {
              "line": 8,
              "column": 13
            }
          ]
        }
      ]
    },
    {
      "name": "ReportsDeepConflictToNearestCommonAncestorInFragments",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          ...F\n        }\n        field {\n          ...F\n        }\n      }\n      fragment F on T {\n        deepField {\n          deeperField {\n            x: a\n          }\n          deeperField {\n            x: b\n          }\n        },\n        deepField {\n          deeperField {\n            y\n          }\n        }\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"deeperField\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 12,
              "column": 11
            },
            {
              "line": 13,
              "column": 13
            },
            {
              "line": 15,
              "column": 11
            },
            {
              "line": 16,
              "column": 13
            }
          ]
        }
      ]
    },
    {
      "name": "ReportsDeepConflictInNestedFragments",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field {\n          ...F\n        }\n        field {\n          ...I\n        }\n      }\n      fragment F on T {\n        x: a\n        ...G\n      }\n      fragment G on T {\n        y: c\n      }\n      fragment I on T {\n        y: d\n        ...J\n      }\n      fragment J on T {\n        x: b\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"field\" conflict because subfields \"x\" conflict because \"a\" and \"b\" are different fields and subfields \"y\" conflict because \"c\" and \"d\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 3,
              "column": 9
            },
            {
              "line": 11,
              "column": 9
            },
            {
              "line": 15,
              "column": 9
            },
            {
              "line": 6,
              "column": 9
            },
            {
              "line": 22,
              "column": 9
            },
            {
              "line": 18,
              "column": 9
            }
          ]
        }
      ]
    },
    {
      "name": "IgnoresUnknownFragments",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      {\n        field\n        ...Unknown\n        ...Known\n      }\n\n      fragment Known on T {\n        field\n        ...OtherUnknown\n      }\n    ",
      "errors": []
    },
    {
      "name": "ConflictingReturnTypesWhichPotentiallyOverlap",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ...on IntBox {\n                scalar\n              }\n              ...on NonNullStringBox1 {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"scalar\" conflict because they return conflicting types \"Int\" and \"String!\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 8,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "CompatibleReturnShapesOnDifferentReturnTypes",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on SomeBox {\n                deepBox {\n                  unrelatedField\n                }\n              }\n              ... on StringBox {\n                deepBox {\n                  unrelatedField\n                }\n              }\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "DisallowsDifferingReturnTypesDespiteNoOverlap",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                scalar\n              }\n              ... on StringBox {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"scalar\" conflict because they return conflicting types \"Int\" and \"String\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 8,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "ReportsCorrectlyWhenANon-exclusiveFollowsAnExclusive",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                deepBox {\n                  ...X\n                }\n              }\n            }\n            someBox {\n              ... on StringBox {\n                deepBox {\n                  ...Y\n                }\n              }\n            }\n            memoed: someBox {\n              ... on IntBox {\n                deepBox {\n                  ...X\n                }\n              }\n            }\n            memoed: someBox {\n              ... on StringBox {\n                deepBox {\n                  ...Y\n                }\n              }\n            }\n            other: someBox {\n              ...X\n            }\n            other: someBox {\n              ...Y\n            }\n          }\n          fragment X on SomeBox {\n            scalar\n          }\n          fragment Y on SomeBox {\n            scalar: unrelatedField\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"other\" conflict because subfields \"scalar\" conflict because \"scalar\" and \"unrelatedField\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 31,
              "column": 13
            },
            {
              "line": 39,
              "column": 13
            },
            {
              "line": 34,
              "column": 13
            },
            {
              "line": 42,
              "column": 13
            }
          ]
        }
      ]
    },
    {
      "name": "DisallowsDifferingReturnTypeNullabilityDespiteNoOverlap",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on NonNullStringBox1 {\n                scalar\n              }\n              ... on StringBox {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"scalar\" conflict because they return conflicting types \"String!\" and \"String\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 8,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "DisallowsDifferingReturnTypeListDespiteNoOverlap",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                box: listStringBox {\n                  scalar\n                }\n              }\n              ... on StringBox {\n                box: stringBox {\n                  scalar\n                }\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"box\" conflict because they return conflicting types \"[StringBox]\" and \"StringBox\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 10,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "LimitsLotsOfFieldSuggestions",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                box: stringBox {\n                  scalar\n                }\n              }\n              ... on StringBox {\n                box: listStringBox {\n                  scalar\n                }\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"box\" conflict because they return conflicting types \"StringBox\" and \"[StringBox]\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 10,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "DisallowsDifferingSubfields",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                box: stringBox {\n                  val: scalar\n                  val: unrelatedField\n                }\n              }\n              ... on StringBox {\n                box: stringBox {\n                  val: scalar\n                }\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"val\" conflict because \"scalar\" and \"unrelatedField\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 6,
              "column": 19
            },
            {
              "line": 7,
              "column": 19
            }
          ]
        }
      ]
    },
    {
      "name": "DisallowsDifferingDeepReturnTypesDespiteNoOverlap",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                box: stringBox {\n                  scalar\n                }\n              }\n              ... on StringBox {\n                box: intBox {\n                  scalar\n                }\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"box\" conflict because subfields \"scalar\" conflict because they return conflicting types \"String\" and \"Int\". Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 17
            },
            {
              "line": 6,
              "column": 19
            },
            {
              "line": 10,
              "column": 17
            },
            {
              "line": 11,
              "column": 19
            }
          ]
        }
      ]
    },
    {
      "name": "AllowsNon-conflictingOverlappingTypes",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ... on IntBox {\n                scalar: unrelatedField\n              }\n              ... on StringBox {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "SameWrappedScalarReturnTypes",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ...on NonNullStringBox1 {\n                scalar\n              }\n              ...on NonNullStringBox2 {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "AllowsInlineFragmentsWithoutTypeCondition",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            a\n            ... {\n              a\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "ComparesDeepTypesIncludingList",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            connection {\n              ...edgeID\n              edges {\n                node {\n                  id: name\n                }\n              }\n            }\n          }\n\n          fragment edgeID on Connection {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        ",
      "errors": [
        {
          "message": "Fields \"edges\" conflict because subfields \"node\" conflict because subfields \"id\" conflict because \"name\" and \"id\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 5,
              "column": 15
            },
            {
              "line": 6,
              "column": 17
            },
            {
              "line": 7,
              "column": 19
            },
            {
              "line": 14,
              "column": 13
            },
            {
              "line": 15,
              "column": 15
            },
            {
              "line": 16,
              "column": 17
            }
          ]
        }
      ]
    },
    {
      "name": "IgnoresUnknownTypes",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 16,
      "query": "\n          {\n            someBox {\n              ...on UnknownType {\n                scalar\n              }\n              ...on NonNullStringBox2 {\n                scalar\n              }\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "WorksForFieldNamesThatAreJSKeywords",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 17,
      "query": "\n          {\n            foo {\n              constructor\n            }\n          }\n        ",
      "errors": []
    },
    {
      "name": "DoesNotInfiniteLoopOnRecursiveFragment",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment fragA on Human { name, relatives { name, ...fragA } }\n    ",
      "errors": []
    },
    {
      "name": "DoesNotInfiniteLoopOnImmediatelyRecursiveFragment",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment fragA on Human { name, ...fragA }\n    ",
      "errors": []
    },
    {
      "name": "DoesNotInfiniteLoopOnTransitivelyRecursiveFragment",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment fragA on Human { name, ...fragB }\n      fragment fragB on Human { name, ...fragC }\n      fragment fragC on Human { name, ...fragA }\n    ",
      "errors": []
    },
    {
      "name": "FindsInvalidCaseEvenWithImmediatelyRecursiveFragment",
      "rule": "OverlappingFieldsCanBeMerged",
      "schema": 0,
      "query": "\n      fragment sameAliasesWithDifferentFieldTargets on Dog {\n        ...sameAliasesWithDifferentFieldTargets\n        fido: name\n        fido: nickname\n      }\n    ",
      "errors": [
        {
          "message": "Fields \"fido\" conflict because \"name\" and \"nickname\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",
          "locations": [
            {
              "line": 4,
              "column": 9
            },
            {
              "line": 5,
              "column": 9
            }
          ]
        }
      ]
    }
  ]
}